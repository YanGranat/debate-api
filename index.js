import express from "express";
import cors from "cors";
import { v4 as uuid } from "uuid";
import Redis from "ioredis";
import axios from "axios";

// ==================
// –û–°–ù–û–í–ù–´–ï –ù–ê–°–¢–†–û–ô–ö–ò
// ==================

const app = express();
app.use(cors());
app.use(express.json());

// –ü–æ–ª—É—á–∞–µ–º –ø—Ä–µ—Ñ–∏–∫—Å –∏–∑ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è, —á—Ç–æ–±—ã –∏–∑–æ–ª–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —ç—Ç–æ–≥–æ –ø—Ä–æ–µ–∫—Ç–∞
const REDIS_PREFIX = process.env.REDIS_PREFIX || 'debate-arena:';

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –¥–æ–±–∞–≤–ª—è–µ—Ç –ø—Ä–µ—Ñ–∏–∫—Å –∫–æ –≤—Å–µ–º –∫–ª—é—á–∞–º –≤ Redis
const prefixKey = (key) => `${REDIS_PREFIX}${key}`;

// –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Redis
const redis = new Redis(process.env.REDIS_URL);
redis.on("connect", () => console.log("‚úÖ Redis connected"));
redis.on("error", (err) => console.error("üõë Redis error", err));

// ==================
// –ö–õ–Æ–ß–ò –î–õ–Ø REDIS (—É–∂–µ —Å –ø—Ä–µ—Ñ–∏–∫—Å–∞–º–∏)
// ==================

const KEY_USER = (id) => prefixKey(`user:${id}`);
const KEY_CLAIMS = (id) => prefixKey(`claims:${id}`);
const KEY_DEBATES = (id) => prefixKey(`debates:${id}`);
const KEY_DEBATE = (id) => prefixKey(`debate:${id}`);
const KEY_HISTORY = (id) => prefixKey(`history:${id}`);
const KEY_SUMMARY = (id) => prefixKey(`summary:${id}`);
const KEY_STATS = (id) => prefixKey(`stats:${id}`);
const KEY_LEADER = prefixKey("leaderboard");
const KEY_INBOX = (id) => prefixKey(`inbox:${id}`);
const KEY_FINISH = (id) => prefixKey(`finish:${id}`);
const KEY_INACTIVE_USERS = prefixKey("users:inactive");
const KEY_INVITATION = (id) => prefixKey(`invitation:${id}`);
const KEY_USER_INVITATIONS = (id) => prefixKey(`invitations:${id}`);

// ==================
// –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò API (—ç–Ω–¥–ø–æ–∏–Ω—Ç—ã)
// ==================

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

app.post("/user", async (req, res) => {
    try {
        const { name, bio } = req.body;
        // –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        if (!name || typeof name !== 'string' || name.trim() === '') {
            return res.status(400).json({ error: "Name is required and must be a non-empty string." });
        }

        const id = name;
        const exists = await redis.exists(KEY_USER(id));
        if (exists) {
            return res.status(409).json({ error: "User already exists", userId: id });
        }

        await redis.hset(KEY_USER(id), {
            name,
            bio: bio || "–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω–∞.",
            status: "inactive",
            createdAt: Date.now(),
        });
        await redis.sadd(KEY_INACTIVE_USERS, id);

        res.status(201).json({ userId: id, name });
    } catch (error) {
        console.error("Error in POST /user:", error);
        res.status(500).json({ error: "Internal server error" });
    }
});

app.get("/user/:id", async (req, res) => {
    try {
        const { id } = req.params;
        const data = await redis.hgetall(KEY_USER(id));
        // –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–π–¥–µ–Ω
        if (!data || Object.keys(data).length === 0) {
            return res.status(404).json({ error: "User not found" });
        }
        res.json({ userId: id, ...data });
    } catch (error) {
        console.error(`Error in GET /user/${req.params.id}:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

app.patch("/user/:id", async (req, res) => {
    try {
        const { id } = req.params;
        const exists = await redis.exists(KEY_USER(id));
        if (!exists) return res.status(404).json({ error: "User not found" });

        const updates = {};
        if (req.body.status) updates.status = req.body.status;
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –¥—Ä—É–≥–∏–µ –ø–æ–ª—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–¥–µ—Å—å

        if (Object.keys(updates).length > 0) {
            await redis.hset(KEY_USER(id), updates);
            if (updates.status === "active") {
                await redis.srem(KEY_INACTIVE_USERS, id);
            }
        }
        res.json({ userId: id, message: "Profile updated successfully." });
    } catch (error) {
        console.error(`Error in PATCH /user/${req.params.id}:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

app.get("/inbox/:user", async (req, res) => {
    try {
        const key = KEY_INBOX(req.params.user);
        const msgs = await redis.lrange(key, 0, -1);
        if (msgs.length > 0) {
            // –û—á–∏—â–∞–µ–º inbox –ø–æ—Å–ª–µ –ø—Ä–æ—á—Ç–µ–Ω–∏—è
            await redis.del(key);
        }
        res.json(msgs);
    } catch (error) {
        console.error(`Error in GET /inbox/${req.params.user}:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});


// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –£—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (claims) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

app.post("/user/:user/claim", async (req, res) => {
    try {
        // –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è —Ç–µ–∫—Å—Ç–∞ —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è
        if (!req.body.text || typeof req.body.text !== 'string' || req.body.text.trim() === '') {
            return res.status(400).json({ error: "Claim text is required." });
        }
        const claim = { id: uuid(), text: req.body.text, ts: Date.now() };
        await redis.rpush(KEY_CLAIMS(req.params.user), JSON.stringify(claim));
        res.status(201).json(claim);
    } catch (error) {
        console.error(`Error in POST /user/${req.params.user}/claim:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

// ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±—É–¥–µ—Ç —Å–ª–µ–¥–æ–≤–∞—Ç—å —Ç–æ–º—É –∂–µ —à–∞–±–ª–æ–Ω—É –∑–∞—â–∏—Ç—ã)
// –ü–æ–ª–Ω—ã–π –∫–æ–¥ –Ω–∏–∂–µ

app.get("/user/:user/claims", async (req, res) => {
  try {
    const raw = await redis.lrange(KEY_CLAIMS(req.params.user), 0, -1);
    res.json(raw.map(JSON.parse));
  } catch (error) {
      console.error(`Error in GET /user/${req.params.user}/claims:`, error);
      res.status(500).json({ error: "Internal server error" });
  }
});

app.delete("/user/:user/claim/:claimId", async (req, res) => {
  try {
    const key = KEY_CLAIMS(req.params.user);
    const list = await redis.lrange(key, 0, -1);
    const claimToDelete = list.find(item => JSON.parse(item).id === req.params.claimId);

    if (claimToDelete) {
      await redis.lrem(key, 0, claimToDelete);
      return res.json({ deleted: true, claimId: req.params.claimId });
    }
    
    res.status(404).json({ deleted: false, error: "Claim not found" });
  } catch (error) {
    console.error(`Error in DELETE /user/${req.params.user}/claim/${req.params.claimId}:`, error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/user/:user/contradictions", async (req, res) => {
  try {
    const keys = await redis.keys(prefixKey("claims:*"));
    const out = {};
    for (const k of keys) {
      const u = k.split(":")[2]; // Adjusted for prefix
      if (u === req.params.user) continue;
      const raw = await redis.lrange(k, 0, -1);
      if (raw.length > 0) {
        out[u] = raw.map(JSON.parse);
      }
    }
    res.json({ user: req.params.user, contradictions: out });
  } catch (error) {
    console.error(`Error in GET /user/${req.params.user}/contradictions:`, error);
    res.status(500).json({ error: "Internal server error" });
  }
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ü–æ–∏—Å–∫ –æ–ø–ø–æ–Ω–µ–Ω—Ç–æ–≤ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

app.get("/match/:user", async (req, res) => {
  try {
    const fullUrl = `${req.protocol}://${req.get('host')}/user/${req.params.user}/contradictions`;
    const response = await axios.get(fullUrl);
    const data = response.data.contradictions;
    const list = [];
    for (const opponentName in data) {
      for (const claim of data[opponentName]) {
        list.push({
          opponent: opponentName,
          claimId: claim.id,
          text: claim.text,
        });
      }
    }
    res.json(list);
  } catch (error) {
    console.error(`Error in GET /match/${req.params.user}:`, error);
    res.status(500).json({ error: "Failed to fetch contradictions", details: error.message });
  }
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

app.post("/invitation", async (req, res) => {
  try {
    const { fromUser, toUser, topic } = req.body;
    // –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if (!fromUser || !toUser || !topic) {
        return res.status(400).json({ error: "fromUser, toUser, and topic are required." });
    }
    const invitationId = uuid();
    await redis.hset(KEY_INVITATION(invitationId), { fromUser, toUser, topic, createdAt: Date.now() });
    await redis.rpush(KEY_USER_INVITATIONS(toUser), invitationId);
    await redis.rpush(KEY_INBOX(toUser), `üì© –£ –≤–∞—Å –Ω–æ–≤–æ–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–∞ –¥–µ–±–∞—Ç—ã –æ—Ç ${fromUser} –Ω–∞ —Ç–µ–º—É ¬´${topic}¬ª. ID –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è: ${invitationId}`);
    res.status(201).json({ invitationId, message: "–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ." });
  } catch (error) {
      console.error("Error in POST /invitation:", error);
      res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/invitation/:id/accept", async (req, res) => {
    try {
        const { id } = req.params;
        const invData = await redis.hgetall(KEY_INVITATION(id));
        if (!invData.fromUser) return res.status(404).json({ error: "–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –∏–ª–∏ —É–∂–µ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ." });
        const { fromUser, toUser, topic } = invData;
        const debateId = uuid();
        await redis.hset(KEY_DEBATE(debateId), { userA: fromUser, userB: toUser, topic, status: "active", turn: toUser, createdAt: Date.now() });
        await Promise.all([redis.rpush(KEY_DEBATES(fromUser), debateId), redis.rpush(KEY_DEBATES(toUser), debateId)]);
        await redis.rpush(KEY_INBOX(fromUser), `‚úÖ ${toUser} –ø—Ä–∏–Ω—è–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ! –î–µ–±–∞—Ç—ã –Ω–∞ —Ç–µ–º—É ¬´${topic}¬ª –Ω–∞—á–∞—Ç—ã. ID –¥–µ–±–∞—Ç–∞: ${debateId}. –í–∞—à –æ–ø–ø–æ–Ω–µ–Ω—Ç –¥–µ–ª–∞–µ—Ç –ø–µ—Ä–≤—ã–π —Ö–æ–¥.`);
        await redis.del(KEY_INVITATION(id));
        await redis.lrem(KEY_USER_INVITATIONS(toUser), 0, id);
        res.json({ debateId, message: "–î–µ–±–∞—Ç—ã –Ω–∞—á–∞—Ç—ã! –í—ã –¥–µ–ª–∞–µ—Ç–µ –ø–µ—Ä–≤—ã–π —Ö–æ–¥." });
    } catch (error) {
        console.error(`Error in POST /invitation/${req.params.id}/accept:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

app.post("/invitation/:id/reject", async (req, res) => {
    try {
        const { id } = req.params;
        const invData = await redis.hgetall(KEY_INVITATION(id));
        if (!invData.fromUser) return res.status(404).json({ error: "–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ." });
        const { fromUser, toUser, topic } = invData;
        await redis.rpush(KEY_INBOX(fromUser), `‚ùå ${toUser} –æ—Ç–∫–ª–æ–Ω–∏–ª(–∞) –≤–∞—à–µ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–∞ –¥–µ–±–∞—Ç—ã –Ω–∞ —Ç–µ–º—É ¬´${topic}¬ª.`);
        await redis.del(KEY_INVITATION(id));
        await redis.lrem(KEY_USER_INVITATIONS(toUser), 0, id);
        res.json({ message: "–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ." });
    } catch (error) {
        console.error(`Error in POST /invitation/${req.params.id}/reject:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

app.get("/user/:user/invitations", async (req, res) => {
    try {
        const ids = await redis.lrange(KEY_USER_INVITATIONS(req.params.user), 0, -1);
        const invitations = [];
        for (const id of ids) {
            const data = await redis.hgetall(KEY_INVITATION(id));
            if (data.fromUser) {
                invitations.push({ invitationId: id, ...data });
            }
        }
        res.json(invitations);
    } catch (error) {
        console.error(`Error in GET /user/${req.params.user}/invitations:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –î–µ–±–∞—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

app.get("/debates/:user", async (req, res) => {
  try {
    const ids = await redis.lrange(KEY_DEBATES(req.params.user), 0, -1);
    const out = [];
    for (const id of ids) {
      const m = await redis.hgetall(KEY_DEBATE(id));
      if (Object.keys(m).length > 0) {
        out.push({ debateId: id, ...m });
      }
    }
    res.json(out);
  } catch (error) {
    console.error(`Error in GET /debates/${req.params.user}:`, error);
    res.status(500).json({ error: "Internal server error" });
  }
});

app.post("/debate/:id/message", async (req, res) => {
  try {
    const { from, text } = req.body;
    const debateId = req.params.id;
    // –ó–ê–©–ò–¢–ê: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    if (!from || !text) {
        return res.status(400).json({ error: "from and text are required." });
    }
    const msg = { from, text, ts: Date.now() };
    const m = await redis.hgetall(KEY_DEBATE(debateId));
    if(m.status !== 'active') return res.status(403).json({ error: "Debate is not active." });

    await redis.rpush(KEY_HISTORY(debateId), JSON.stringify(msg));
    const to = from === m.userA ? m.userB : m.userA;
    await redis.hset(KEY_DEBATE(debateId), 'turn', to); // –°–º–µ–Ω–∞ —Ö–æ–¥–∞
    await redis.rpush(KEY_INBOX(to),`üí¨ –ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –¥–µ–±–∞—Ç–µ ¬´${m.topic}¬ª (ID: ${debateId}) –æ—Ç ${from}: ${text}`);
    res.json({ delivered: true });
  } catch(error) {
      console.error(`Error in POST /debate/${req.params.id}/message:`, error);
      res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/debate/:id/history", async (req, res) => {
    try {
        const history = (await redis.lrange(KEY_HISTORY(req.params.id), 0, -1)).map(JSON.parse);
        res.json(history);
    } catch(error) {
        console.error(`Error in GET /debate/${req.params.id}/history:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

app.post("/debate/:id/finish", async (req, res) => {
  try {
    const { user, wantWinner } = req.body;
    if (user === undefined || wantWinner === undefined) {
        return res.status(400).json({ error: "user and wantWinner are required." });
    }
    const id = req.params.id;
    await redis.setex(`${KEY_FINISH(id)}:${user}`, 3600, wantWinner ? "want" : "no");
    const m = await redis.hgetall(KEY_DEBATE(id));
    const other = user === m.userA ? m.userB : m.userA;
    const otherFlag = await redis.get(`${KEY_FINISH(id)}:${other}`);

    if (wantWinner === false || otherFlag === "no") {
        await redis.hset(KEY_DEBATE(id), "status", "ended", "endedAt", Date.now());
        await redis.rpush(KEY_INBOX(other), `‚ÑπÔ∏è ${user} –∑–∞–≤–µ—Ä—à–∏–ª(–∞) –¥–µ–±–∞—Ç ¬´${m.topic}¬ª.`);
        return res.json({ ended: true, winner: null });
    }

    if (otherFlag === "want") {
        const hist = (await redis.lrange(KEY_HISTORY(id), 0, -1)).map(JSON.parse);
        const cnt = hist.reduce((a, x) => {
            a[x.from] = (a[x.from] || 0) + 1;
            return a;
        }, {});
        const winner = (cnt[m.userA] || 0) >= (cnt[m.userB] || 0) ? m.userA : m.userB;
        const loser = winner === m.userA ? m.userB : m.userA;

        await redis.hset(KEY_DEBATE(id),"status","ended","winner",winner,"endedAt",Date.now());
        await redis.hincrby(KEY_STATS(winner), "wins", 1);
        await redis.hincrby(KEY_STATS(loser), "losses", 1);

        const [winsW, lossesW] = await redis.hmget(KEY_STATS(winner), "wins", "losses");
        const [winsL, lossesL] = await redis.hmget(KEY_STATS(loser), "wins", "losses");

        await redis.zadd(KEY_LEADER, Number(winsW || 0) - Number(lossesW || 0), winner);
        await redis.zadd(KEY_LEADER, Number(winsL || 0) - Number(lossesL || 0), loser);

        await redis.rpush(KEY_INBOX(other), `üèÜ –î–µ–±–∞—Ç ¬´${m.topic}¬ª –∑–∞–≤–µ—Ä—à–µ–Ω. –ü–æ–±–µ–¥–∏—Ç–µ–ª—å: ${winner}!`);
        return res.json({ ended: true, winner });
    }

    await redis.rpush(KEY_INBOX(other),`‚úÖ ${user} –ø—Ä–µ–¥–ª–æ–∂–∏–ª –∑–∞–≤–µ—Ä—à–∏—Ç—å –¥–µ–±–∞—Ç (ID: ${id}) –∏ –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å –ø–æ–±–µ–¥–∏—Ç–µ–ª—è. –î–ª—è —Å–æ–≥–ª–∞—Å–∏—è –≤—ã–∑–æ–≤–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è.`);
    res.json({ awaitingConfirmation: true });
  } catch(error) {
      console.error(`Error in POST /debate/${req.params.id}/finish:`, error);
      res.status(500).json({ error: "Internal server error" });
  }
});

app.get("/user/:user/context", async (req, res) => {
  try {
    const u = req.params.user;
    const claims = (await redis.lrange(KEY_CLAIMS(u), 0, -1)).map(JSON.parse);
    const debateIds = await redis.lrange(KEY_DEBATES(u), 0, -1);
    const debates = [];
    for(const id of debateIds) {
        const debateData = await redis.hgetall(KEY_DEBATE(id));
        if (Object.keys(debateData).length > 0) {
            debates.push({ debateId: id, ...debateData });
        }
    }
    
    const stats = await redis.hgetall(KEY_STATS(u));
    const lb = await redis.zrevrange(KEY_LEADER, 0, 4, "WITHSCORES");
    const leaderboard = [];
    for (let i = 0; i < lb.length; i += 2) {
      leaderboard.push({ user: lb[i], score: Number(lb[i + 1]) });
    }
    const userProfile = await redis.hgetall(KEY_USER(u));
    const invitationIds = await redis.lrange(KEY_USER_INVITATIONS(u), 0, -1);
    const invitations = [];
    for (const id of invitationIds) {
        const invData = await redis.hgetall(KEY_INVITATION(id));
        if (invData.fromUser) {
            invitations.push({ invitationId: id, ...invData });
        }
    }
    
    res.json({ user: u, profile: userProfile, claims, debates, stats, leaderboard, invitations });
  } catch (error) {
    console.error(`Error in GET /user/${req.params.user}/context:`, error);
    res.status(500).json({ error: "Failed to fetch user context", details: error.message });
  }
});

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ —Å–ª—É–∂–µ–±–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

app.get("/leaderboard", async (_req, res) => {
    try {
        const d = await redis.zrevrange(KEY_LEADER, 0, 4, "WITHSCORES");
        const out = [];
        for (let i = 0; i < d.length; i += 2)
            out.push({ user: d[i], score: Number(d[i + 1]) });
        res.json(out);
    } catch (error) {
        console.error("Error in GET /leaderboard:", error);
        res.status(500).json({ error: "Internal server error" });
    }
});

app.get("/openapi.json", (req, res) => {
  // –≠—Ç–∞ —á–∞—Å—Ç—å –∫–æ–¥–∞ –æ—Å—Ç–∞–µ—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π, —Ç.–∫. –æ–Ω–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å—Ç–∞—Ç–∏—á–Ω—É—é —Å—Ö–µ–º—É
  // –∏ –Ω–µ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤—É–µ—Ç —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö.
  const host = req.get('host');
  const schema = {
    openapi: "3.1.0",
    info: { title: "Debate Arena API", version: "v1.2.0-stable" },
    servers: [{ url: `https://${host}` }],
    paths: {
      "/user": { post: { summary: "–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.", operationId: "createUser", requestBody: { required: true, content: { "application/json": { schema: { type: "object", properties: { name: { type: "string" }, bio: { type: "string" } }, required: ["name"] } } } }, responses: { "201": { description: "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å–æ–∑–¥–∞–Ω." } } } },
      "/user/{id}": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å.", operationId: "getUserProfile", parameters: [{ name: "id", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } }, patch: { summary: "–û–±–Ω–æ–≤–∏—Ç—å –ø—Ä–æ—Ñ–∏–ª—å.", operationId: "updateUserProfile", parameters: [{ name: "id", in: "path", required: true, schema: { type: "string" } }], requestBody: { required: true, content: { "application/json": { schema: { type: "object", properties: { status: { type: "string", enum: ["active", "inactive"] } } } } } }, responses: { "200": { description: "OK." } } } },
      "/inbox/{user}": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è.", operationId: "getInboxMessages", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } } },
      "/user/{user}/claim": { post: { summary: "–î–æ–±–∞–≤–∏—Ç—å —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.", operationId: "addClaim", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }], requestBody: { required: true, content: { "application/json": { schema: { type: "object", properties: { text: { type: "string" } }, required: ["text"] } } } }, responses: { "201": { description: "OK." } } } },
      "/user/{user}/claims": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è.", operationId: "getClaims", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } } },
      "/user/{user}/claim/{claimId}": { delete: { summary: "–£–¥–∞–ª–∏—Ç—å —É—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ.", operationId: "deleteClaim", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }, { name: "claimId", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } } },
      "/match/{user}": { get: { summary: "–ù–∞–π—Ç–∏ –æ–ø–ø–æ–Ω–µ–Ω—Ç–æ–≤.", operationId: "findMatches", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } } },
      "/invitation": { post: { summary: "–°–æ–∑–¥–∞—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–∞ –¥–µ–±–∞—Ç—ã.", operationId: "createInvitation", requestBody: { required: true, content: { "application/json": { schema: { type: "object", properties: { fromUser: { type: "string" }, toUser: { type: "string" }, topic: { type: "string" } }, required: ["fromUser", "toUser", "topic"] } } } }, responses: { "201": { description: "–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ." } } } },
      "/user/{user}/invitations": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Ö–æ–¥—è—â–∏—Ö –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π.", operationId: "getInvitations", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "–°–ø–∏—Å–æ–∫ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–π." } } } },
      "/invitation/{id}/accept": { post: { summary: "–ü—Ä–∏–Ω—è—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ.", operationId: "acceptInvitation", parameters: [{ name: "id", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "–î–µ–±–∞—Ç—ã –Ω–∞—á–∞—Ç—ã." } } } },
      "/invitation/{id}/reject": { post: { summary: "–û—Ç–∫–ª–æ–Ω–∏—Ç—å –ø—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ.", operationId: "rejectInvitation", parameters: [{ name: "id", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –æ—Ç–∫–ª–æ–Ω–µ–Ω–æ." } } } },
      "/debates/{user}": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å –¥–µ–±–∞—Ç—ã.", operationId: "getDebates", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } } },
      "/debate/{id}/history": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é.", operationId: "getDebateHistory", parameters: [{ name: "id", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } } },
      "/debate/{id}/message": { post: { summary: "–û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ.", operationId: "sendMessage", parameters: [{ name: "id", in: "path", required: true, schema: { type: "string" } }], requestBody: { required: true, content: { "application/json": { schema: { type: "object", properties: { from: { type: "string" }, text: { type: "string" } }, required: ["from", "text"] } } } }, responses: { "200": { description: "OK." } } } },
      "/debate/{id}/finish": { post: { summary: "–ó–∞–≤–µ—Ä—à–∏—Ç—å –¥–µ–±–∞—Ç.", operationId: "finishDebate", parameters: [{ name: "id", in: "path", required: true, schema: { type: "string" } }], requestBody: { required: true, content: { "application/json": { schema: { type: "object", properties: { user: { type: "string" }, wantWinner: { type: "boolean" } }, required: ["user", "wantWinner"] } } } }, responses: { "200": { description: "OK." } } } },
      "/user/{user}/context": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç.", operationId: "getUserContext", parameters: [{ name: "user", in: "path", required: true, schema: { type: "string" } }], responses: { "200": { description: "OK." } } } },
      "/leaderboard": { get: { summary: "–ü–æ–ª—É—á–∏—Ç—å –ª–∏–¥–µ—Ä–±–æ—Ä–¥.", operationId: "getLeaderboard", responses: { "200": { description: "–¢–æ–ø-5 –ª–∏–¥–µ—Ä–æ–≤." } } } }
    }
  };
  res.json(schema);
});

// –ü—Ä–æ—Å—Ç–æ–π —ç–Ω–¥–ø–æ–∏–Ω—Ç –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏, —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –∂–∏–≤
app.get("/ping", (_req, res) => res.json({ ok: true, timestamp: Date.now() }));

// –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–µ—Ä–∞
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üöÄ Server listening on port ${PORT}`));
